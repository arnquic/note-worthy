use axum::{
    Router,
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{delete, get, post, put},
};
use sea_orm::{
    ActiveModelTrait, ActiveValue::NotSet, ColumnTrait, DatabaseConnection, DbErr, EntityTrait,
    PaginatorTrait, QueryFilter, QueryOrder, Set,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tower_http::cors::CorsLayer;
use uuid::Uuid;

// Database Entity (generated by sea-orm-cli or manually created)
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]

pub struct Model {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,
    pub first_name: String,
    pub last_name: String,
    pub phone: Option<String>,
    pub date_of_birth: Option<chrono::NaiveDate>,
    pub user_type: UserType,
    pub is_active: bool,
    pub emergency_contact_name: Option<String>,
    pub emergency_contact_phone: Option<String>,
    pub therapist_license_number: Option<String>,
    pub specializations: Option<String>, // JSON array as string
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "user_type")]
pub enum UserType {
    #[sea_orm(string_value = "client")]
    Client,
    #[sea_orm(string_value = "therapist")]
    Therapist,
    #[sea_orm(string_value = "admin")]
    Admin,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

// DTOs for API requests/responses
#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub email: String,
    pub password: String,
    pub first_name: String,
    pub last_name: String,
    pub phone: Option<String>,
    pub date_of_birth: Option<chrono::NaiveDate>,
    pub user_type: UserType,
    pub emergency_contact_name: Option<String>,
    pub emergency_contact_phone: Option<String>,
    pub therapist_license_number: Option<String>,
    pub specializations: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserRequest {
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub phone: Option<String>,
    pub date_of_birth: Option<chrono::NaiveDate>,
    pub emergency_contact_name: Option<String>,
    pub emergency_contact_phone: Option<String>,
    pub therapist_license_number: Option<String>,
    pub specializations: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub first_name: String,
    pub last_name: String,
    pub phone: Option<String>,
    pub date_of_birth: Option<chrono::NaiveDate>,
    pub user_type: UserType,
    pub is_active: bool,
    pub emergency_contact_name: Option<String>,
    pub emergency_contact_phone: Option<String>,
    pub therapist_license_number: Option<String>,
    pub specializations: Option<Vec<String>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Deserialize)]
pub struct UsersQuery {
    pub page: Option<u64>,
    pub per_page: Option<u64>,
    pub user_type: Option<UserType>,
    pub is_active: Option<bool>,
}

// Application state
#[derive(Clone)]
pub struct AppState {
    db: DatabaseConnection,
}

// API Handlers

// Router setup

// Main function example
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Database connection setup
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://user:password@localhost/therapy_app".to_string());

    let db = sea_orm::Database::connect(&database_url).await?;

    // Create router

    // Start server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Server running on http://0.0.0.0:3000");

    Ok(())
}
